(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{432:function(t,r,a){"use strict";a.r(r);var e=a(15),v=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h2",{attrs:{id:"一、let与const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、let与const"}},[t._v("#")]),t._v(" 一、let与const")]),t._v(" "),a("ol",[a("li",[t._v("let 不允许变量提升")]),t._v(" "),a("li",[t._v("暂时性死区：到达定义之前也没法获取和使用全局的同名变量")]),t._v(" "),a("li",[t._v("块级作用域")])]),t._v(" "),a("p",[t._v("const不能锁定变量，要锁定变量，需要使用：object.freeze()")]),t._v(" "),a("h2",{attrs:{id:"二、解构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、解构赋值"}},[t._v("#")]),t._v(" 二、解构赋值")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[a("strong",[t._v("结构赋值是浅拷贝!")]),t._v("，拷贝单层是深拷贝，拷贝多层就是浅拷贝")])]),t._v(" "),a("p",[t._v("原理即为模式匹配，左右两边模式相同就可以进行赋值。"),a("br"),t._v("\n数组的解构赋值"),a("br"),t._v("\n对象的解构赋值"),a("br"),t._v("\n字符串的解构赋值"),a("br"),t._v("\n数值和布尔值的解构赋值"),a("br"),t._v("\n函数参数的解构赋值"),a("br"),t._v("\n圆括号问题"),a("br"),t._v("\n用途")]),t._v(" "),a("p",[t._v("1、解构赋值中对象的解构赋值需要使用对应的属性名，或者使用冒号转化到指定变量")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("import的时候{}就用的是解构赋值")])]),t._v(" "),a("p",[t._v("2、解构赋值也可以设置默认值")]),t._v(" "),a("h2",{attrs:{id:"三、字符串扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、字符串扩展"}},[t._v("#")]),t._v(" 三、字符串扩展")]),t._v(" "),a("p",[t._v("字符的 Unicode 表示法"),a("br"),t._v("\n字符串的遍历器接口"),a("br"),t._v("\n直接输入 U+2028 和 U+2029"),a("br"),t._v("\nJSON.stringify() 的改造"),a("br"),t._v("\n模板字符串"),a("br"),t._v("\n实例：模板编译"),a("br"),t._v("\n标签模板"),a("br"),t._v("\n模板字符串的限制")]),t._v(" "),a("p",[t._v("1、增加for of循环遍历，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。"),a("br"),t._v("\n2、模板字符串即为使用反引号，其中外部变量使用${}写入")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("模板字符串中的空格和换行都会被保留，也可以放入表达式和函数（有返回值的）")])]),t._v(" "),a("p",[t._v("3、实例：模板编译： 没看太懂"),a("br"),t._v("\n模板编译就是将你所使用的模板转化成原生的js或者html等")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("类似于vue的写法最终转换成原生")])]),t._v(" "),a("h2",{attrs:{id:"四、字符串新增方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、字符串新增方法"}},[t._v("#")]),t._v(" 四、字符串新增方法")]),t._v(" "),a("p",[t._v("String.fromCodePoint()   //String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足")]),t._v(" "),a("p",[t._v("String.raw()  //该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。"),a("br"),t._v("\n实例方法：codePointAt()  //正确处理 4 个字节储存的字符，返回一个字符的码点。"),a("br"),t._v("\n实例方法：normalize()  //用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。"),a("br"),t._v("\n实例方法：includes(), startsWith(), endsWith()   //是否包含，是否在头部，是否在尾部"),a("br"),t._v("\n实例方法：repeat()    //表示将原字符串重复n次"),a("br"),t._v("\n实例方法：padStart()，padEnd()  //ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。常见用途是为数值补全指定位数"),a("br"),t._v("\n实例方法：trimStart()，trimEnd()  //行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。"),a("br"),t._v("\n实例方法：matchAll()   //返回一个正则表达式在当前字符串的所有匹配"),a("br"),t._v("\n实例方法：replaceAll()  //一次性替换所有匹配。返回一个新字符串，不会改变原字符串。"),a("br"),t._v("\n:::error\n对于正则表达式，必须使用/g 否则会报错\n:::")]),t._v(" "),a("h2",{attrs:{id:"五、正则的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、正则的扩展"}},[t._v("#")]),t._v(" 五、正则的扩展")]),t._v(" "),a("p",[t._v("RegExp 构造函数"),a("br"),t._v("\n字符串的正则方法"),a("br"),t._v("\nu 修饰符    //Unicode模式"),a("br"),t._v("\nRegExp.prototype.unicode 属性"),a("br"),t._v("\ny 修饰符"),a("br"),t._v("\nRegExp.prototype.sticky 属性"),a("br"),t._v("\nRegExp.prototype.flags 属性"),a("br"),t._v("\ns 修饰符：dotAll 模式"),a("br"),t._v("\n后行断言"),a("br"),t._v("\nUnicode 属性类"),a("br"),t._v("\n具名组匹配"),a("br"),t._v("\n正则匹配索引"),a("br"),t._v("\nString.prototype.matchAll()")]),t._v(" "),a("h2",{attrs:{id:"六、数值扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、数值扩展"}},[t._v("#")]),t._v(" 六、数值扩展")]),t._v(" "),a("p",[t._v("二进制和八进制表示法"),a("br"),t._v("\n数值分隔符"),a("br"),t._v("\nNumber.isFinite(), Number.isNaN()"),a("br"),t._v("\nNumber.parseInt(), Number.parseFloat()"),a("br"),t._v("\nNumber.isInteger()"),a("br"),t._v("\nNumber.EPSILON"),a("br"),t._v("\n安全整数和 Number.isSafeInteger()"),a("br"),t._v("\nMath 对象的扩展"),a("br"),t._v("\nBigInt 数据类型")]),t._v(" "),a("h2",{attrs:{id:"七、函数的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、函数的扩展"}},[t._v("#")]),t._v(" 七、函数的扩展")]),t._v(" "),a("p",[t._v("函数参数的默认值"),a("br"),t._v("\nrest 参数"),a("br"),t._v("\n严格模式"),a("br"),t._v("\nname 属性"),a("br"),t._v("\n箭头函数"),a("br"),t._v("\n尾调用优化"),a("br"),t._v("\n函数参数的尾逗号"),a("br"),t._v("\nFunction.prototype.toString()"),a("br"),t._v("\ncatch 命令的参数省略")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("尾递归和尾调用可以优化函数运行"),a("br"),t._v("\n函数调用会在内存形成一个调用记录，又称调用帧（call frame），保存调用位置和内部变量等信息，多个函数串联调用就会形成调用栈，尾调用可以释放外层函数的调用帧"),a("br"),t._v("\n递归容易发送栈溢出的问题，尾递归只会存在一个调用帧，不会发生栈溢出")])]),t._v(" "),a("h2",{attrs:{id:"八、数组的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、数组的扩展"}},[t._v("#")]),t._v(" 八、数组的扩展")]),t._v(" "),a("p",[t._v("扩展运算符"),a("br"),t._v("\nArray.from()"),a("br"),t._v("\nArray.of()"),a("br"),t._v("\n数组实例的 copyWithin()"),a("br"),t._v("\n数组实例的 find() 和 findIndex()"),a("br"),t._v("\n数组实例的 fill()"),a("br"),t._v("\n数组实例的 entries()，keys() 和 values()"),a("br"),t._v("\n数组实例的 includes()"),a("br"),t._v("\n数组实例的 flat()，flatMap()"),a("br"),t._v("\n数组的空位"),a("br"),t._v("\nArray.prototype.sort() 的排序稳定性")]),t._v(" "),a("h2",{attrs:{id:"九、对象的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、对象的扩展"}},[t._v("#")]),t._v(" 九、对象的扩展")]),t._v(" "),a("p",[t._v("属性的简洁表示法"),a("br"),t._v("\n属性名表达式"),a("br"),t._v("\n方法的 name 属性"),a("br"),t._v("\n属性的可枚举性和遍历"),a("br"),t._v("\nsuper 关键字    //super，指向当前对象的原型对象。"),a("br"),t._v("\n对象的扩展运算符")]),t._v(" "),a("h2",{attrs:{id:"十、对象的新增方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、对象的新增方法"}},[t._v("#")]),t._v(" 十、对象的新增方法")]),t._v(" "),a("p",[t._v("Object.is()"),a("br"),t._v("\nObject.assign()"),a("br"),t._v("\nObject.getOwnPropertyDescriptors()"),a("br"),t._v("\n__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"),a("br"),t._v("\nObject.keys()，Object.values()，Object.entries()"),a("br"),t._v("\nObject.fromEntries()")]),t._v(" "),a("h2",{attrs:{id:"十一、运算符的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、运算符的扩展"}},[t._v("#")]),t._v(" 十一、运算符的扩展")]),t._v(" "),a("p",[t._v("指数运算符"),a("br"),t._v("\n链判断运算符"),a("br"),t._v("\nNull 判断运算符"),a("br"),t._v("\n逻辑赋值运算符")]),t._v(" "),a("h2",{attrs:{id:"十二、symbol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十二、symbol"}},[t._v("#")]),t._v(" 十二、Symbol")]),t._v(" "),a("p",[t._v("概述"),a("br"),t._v("\nSymbol.prototype.description"),a("br"),t._v("\n作为属性名的 Symbol"),a("br"),t._v("\n实例：消除魔术字符串"),a("br"),t._v("\n属性名的遍历"),a("br"),t._v("\nSymbol.for()，Symbol.keyFor()"),a("br"),t._v("\n实例：模块的 Singleton 模式"),a("br"),t._v("\n内置的 Symbol 值")]),t._v(" "),a("h2",{attrs:{id:"十三、set-和-map-数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十三、set-和-map-数据结构"}},[t._v("#")]),t._v(" 十三、Set 和 Map 数据结构")]),t._v(" "),a("p",[t._v("Set"),a("br"),t._v("\nWeakSet"),a("br"),t._v("\nMap"),a("br"),t._v("\nWeakMap"),a("br"),t._v("\nWeakRef"),a("br"),t._v("\nFinalizationRegistry")]),t._v(" "),a("h2",{attrs:{id:"十四、proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十四、proxy"}},[t._v("#")]),t._v(" 十四、Proxy")]),t._v(" "),a("p",[t._v("概述"),a("br"),t._v("\nProxy 实例的方法"),a("br"),t._v("\nProxy.revocable()"),a("br"),t._v("\nthis 问题"),a("br"),t._v("\n实例：Web 服务的客户端")]),t._v(" "),a("h2",{attrs:{id:"十五、reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十五、reflect"}},[t._v("#")]),t._v(" 十五、Reflect")]),t._v(" "),a("p",[t._v("概述"),a("br"),t._v("\n静态方法"),a("br"),t._v("\n实例：使用 Proxy 实现观察者模式")]),t._v(" "),a("h2",{attrs:{id:"十六、promise-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十六、promise-对象"}},[t._v("#")]),t._v(" 十六、Promise 对象")]),t._v(" "),a("p",[t._v("Promise 的含义"),a("br"),t._v("\n基本用法"),a("br"),t._v("\nPromise.prototype.then()"),a("br"),t._v("\nPromise.prototype.catch()"),a("br"),t._v("\nPromise.prototype.finally()"),a("br"),t._v("\nPromise.all()   //多个promise实例包装为一个，状态都为fulfilled时候，总的才会是fulfilled，有一个rejected就会rejected\nPromise.race()  //多个封装为一个，只要有一个改变就会跟着改变"),a("br"),t._v("\nPromise.allSettled()   //包装， 不管什么状态，全部返回后才处理总的"),a("br"),t._v("\nPromise.any()"),a("br"),t._v("\nPromise.resolve()"),a("br"),t._v("\nPromise.reject()"),a("br"),t._v("\n应用"),a("br"),t._v("\nPromise.try()")]),t._v(" "),a("p",[t._v("1、promise三种状态：pending、fulfilled（resolved）、rejected"),a("br"),t._v("\n2、promise会吃掉报错，也就是说promise报错也不会影响后面的程序运行"),a("br"),t._v("\n3、promise处理方式有三种，.then()/.catch()/.finally()"),a("br"),t._v("\n4、Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。只要其中有一个状态变化了总的状态就跟着变了，可以用来选择最快返回的那个")]),t._v(" "),a("h2",{attrs:{id:"十七、iterator-和-for-of-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十七、iterator-和-for-of-循环"}},[t._v("#")]),t._v(" 十七、Iterator 和 for...of 循环")]),t._v(" "),a("p",[t._v("Iterator（遍历器）的概念"),a("br"),t._v("\n默认 Iterator 接口"),a("br"),t._v("\n调用 Iterator 接口的场合"),a("br"),t._v("\n字符串的 Iterator 接口"),a("br"),t._v("\nIterator 接口与 Generator 函数"),a("br"),t._v("\n遍历器对象的 return()，throw()"),a("br"),t._v("\nfor...of 循环")]),t._v(" "),a("p",[t._v("1、调用遍历器的地方："),a("br"),t._v("\nfor...of"),a("br"),t._v("\nArray.from()"),a("br"),t._v("\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）"),a("br"),t._v("\nPromise.all()"),a("br"),t._v("\nPromise.race()")]),t._v(" "),a("p",[t._v("2、iterator使用方法：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重点：Symbol.iterator属性！")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NodeList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或者")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NodeList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("3、数组遍历的时候可以用for循环、for in（遍历的为键值。且为字符串）、forEach（不能跳出循环）、for of（较好）")]),t._v(" "),a("h2",{attrs:{id:"十八、generator-函数的语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十八、generator-函数的语法"}},[t._v("#")]),t._v(" 十八、Generator 函数的语法")]),t._v(" "),a("p",[t._v("简介"),a("br"),t._v("\nnext 方法的参数"),a("br"),t._v("\nfor...of 循环"),a("br"),t._v("\nGenerator.prototype.throw()"),a("br"),t._v("\nGenerator.prototype.return()"),a("br"),t._v("\nnext()、throw()、return() 的共同点"),a("br"),t._v("\nyield* 表达式"),a("br"),t._v("\n作为对象属性的 Generator 函数"),a("br"),t._v("\nGenerator 函数的this"),a("br"),t._v("\n含义"),a("br"),t._v("\n应用")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Generator返回遍历器对象，有两个特点，一是function函数与名间有个*，二是内部使用yield表达式，定义不同内部状态")])]),t._v(" "),a("li",[a("p",[t._v("yield表达式如果用在另一个表达式之中，必须放在圆括号里面；yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号")])]),t._v(" "),a("li",[a("p",[t._v("可以将Generator函数赋值给变量的Symbol.iterator属性，使变量可以遍历")])]),t._v(" "),a("li",[a("p",[t._v("yield表达式默认返回值为undefined，在调用next()的时候可以传参，此时参数就会被认为是之前一步的返回值，"),a("strong",[t._v("首次next传参无效")])])]),t._v(" "),a("li",[a("p",[t._v("return方法会执行finally中的代码，再返回return中的值，结束")])]),t._v(" "),a("li",[a("p",[t._v("yield* 可以在generator中返回其他generator代码，而不用手动遍历")])]),t._v(" "),a("li",[a("p",[t._v("generator应用：")]),t._v(" "),a("ol",[a("li",[t._v("异步的同步化表达")]),t._v(" "),a("li",[t._v("控制流管理："),a("br"),t._v("\n多步操作可使用：回调、promise、generator（此时只能全是同步）")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("for of 本质是一个while循环，判断res.done，若没有则调用iterator的next（）")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("部署Iterator接口")]),t._v(" "),a("li",[t._v("作为数据结构")])])])]),t._v(" "),a("h2",{attrs:{id:"十九、generator-函数的异步应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十九、generator-函数的异步应用"}},[t._v("#")]),t._v(" 十九、Generator 函数的异步应用")]),t._v(" "),a("p",[t._v("传统方法"),a("br"),t._v("\n基本概念"),a("br"),t._v("\nGenerator 函数"),a("br"),t._v("\nThunk 函数"),a("br"),t._v("\nco 模块")]),t._v(" "),a("ol",[a("li",[t._v("传统方法"),a("br"),t._v("\nes6之前的异步方法：\n"),a("ol",[a("li",[t._v("回调函数")]),t._v(" "),a("li",[t._v("事件监听")]),t._v(" "),a("li",[t._v("发布/订阅")]),t._v(" "),a("li",[t._v("Promise对象")])])]),t._v(" "),a("li",[t._v("基本概念")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？")]),t._v(" "),a("p",[t._v("原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）  \n2. thunk函数：传名调用”的一种实现策略，用来替换某个表达式  \n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("JavaScript 语言是传值调用")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("3. 在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。   \n4. CO模块  \n")])])]),a("h2",{attrs:{id:"二十、async-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十、async-函数"}},[t._v("#")]),t._v(" 二十、async 函数")]),t._v(" "),a("p",[t._v("含义"),a("br"),t._v("\n基本用法"),a("br"),t._v("\n语法"),a("br"),t._v("\nasync 函数的实现原理"),a("br"),t._v("\n与其他异步处理方法的比较"),a("br"),t._v("\n实例：按顺序完成异步操作"),a("br"),t._v("\n顶层 await")]),t._v(" "),a("ol",[a("li",[t._v("async是语法糖，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。")]),t._v(" "),a("li",[t._v("async四个优化点\n"),a("ol",[a("li",[t._v("内置执行器，不需要generator的 next()")]),t._v(" "),a("li",[t._v("更好的语义")]),t._v(" "),a("li",[t._v("更广的适用性（promise和原始类型值都可以）")]),t._v(" "),a("li",[t._v("返回值是promise，直接.then既可")])])])])])}),[],!1,null,null,null);r.default=v.exports}}]);