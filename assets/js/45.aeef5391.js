(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{463:function(a,e,t){"use strict";t.r(e);var r=t(15),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" webpack")]),a._v(" "),t("p",[a._v("webpack作为一个打包工具，其作用有以下几点："),t("br"),a._v("\n1. 模块打包，可以根据模块依赖将各模块代码打包到一起，并且保持其引用顺序正确\n2. 编译兼容，bable转义，webpack可以自动对代码进行bable转义，帮助我们进行代码的polyfill，并且可以转义各种浏览器不能直接识别的文件如vue.js等\n3. 能力扩展：可以使用 loader 和 plugin 机制对webpack打包能力进行扩展")]),a._v(" "),t("h2",{attrs:{id:"webpack打包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包原理"}},[a._v("#")]),a._v(" webpack打包原理")]),a._v(" "),t("h3",{attrs:{id:"webpack打包过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包过程"}},[a._v("#")]),a._v(" webpack打包过程")]),a._v(" "),t("ol",[t("li",[a._v("读取webpack配置")]),a._v(" "),t("li",[a._v("启动webpack，创建 compiler 对项目进行解析")]),a._v(" "),t("li",[a._v("从入口文件（entry）开始解析，调用loader对文件进行解析，解析完成后再查看依赖项，再循环递归解析所有的依赖")]),a._v(" "),t("li",[a._v("解析完依赖后将所有的依赖整理，组装成一个个chunk，再将chunk转化成文件加入输出列表")]),a._v(" "),t("li",[a._v("确认好输出内容，根据配置输出文件")])]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("webpack在打包过程中会在特定时间向外抛出hooks，plugin可以根据这些hooks对打包过程进行干预")]),a._v("\nwebpack的过程主要由 compiler 和 compilation 控制，compiler 是一个全局单例，主要负责整个打包的流程，compilation 是打包过程中的执行上下文，每次重新构建或者热更新都会创建新的 compilation"),t("br"),a._v("\n每个模块之间的关系依赖于AST语法树，每个模块通过loader解析完后，会通过 acorn 库生成模块代码的AST树，通过语法树就可以分析是否还有依赖，从而循环处理依赖")])]),a._v(" "),t("h2",{attrs:{id:"source-map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#source-map"}},[a._v("#")]),a._v(" source map")]),a._v(" "),t("p",[a._v("webpack可以将我们的代码混淆、打包、压缩，处理过后的代码难以阅读，所以不利于调试，source map就是在打包过程中将打包后的代码映射到源码位置去的技术，使用 source map 可以提高 debug 效率")]),a._v(" "),t("h2",{attrs:{id:"hmr原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hmr原理"}},[a._v("#")]),a._v(" HMR原理")]),a._v(" "),t("p",[a._v("Hot Module Replacement\nwebpack监听到有变化后就会重新打包，然后webpack-dev-server（后面称为服务端）和 客户端存在一个websocket，当更新后服务端会通知客户端，并带上hash值，客户端收到消息对比差异后发送ajax请求到服务端，然后客户端根据这些信息发起jsonp请求获取增量更新")]),a._v(" "),t("h2",{attrs:{id:"webpack打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包优化"}},[a._v("#")]),a._v(" webpack打包优化")]),a._v(" "),t("h2",{attrs:{id:"bable原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bable原理"}},[a._v("#")]),a._v(" bable原理")]),a._v(" "),t("h2",{attrs:{id:"loader写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader写法"}},[a._v("#")]),a._v(" loader写法")]),a._v(" "),t("h2",{attrs:{id:"plugin写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin写法"}},[a._v("#")]),a._v(" plugin写法")]),a._v(" "),t("h2",{attrs:{id:"手写webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手写webpack"}},[a._v("#")]),a._v(" 手写webpack")])])}),[],!1,null,null,null);e.default=s.exports}}]);