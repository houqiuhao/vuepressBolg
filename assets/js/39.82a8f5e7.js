(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{457:function(t,a,e){"use strict";e.r(a);var r=e(15),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"http报文结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http报文结构"}},[t._v("#")]),t._v(" http报文结构")]),t._v(" "),e("p",[t._v("http报文分请求报文和响应报文"),e("br"),t._v("\n请求报文分：请求首行（包括 请求方法，请求url，http版本）、请求体（即请求头）、请求内容"),e("br"),t._v("\n响应报文分：响应首行（包括 http版本，状态码，原因），响应体（即响应头），响应内容"),e("br"),t._v("\n三部分之间使用空行隔开")]),t._v(" "),e("h2",{attrs:{id:"http请求方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http请求方法"}},[t._v("#")]),t._v(" http请求方法")]),t._v(" "),e("p",[t._v("get: 通常使用的请求方法"),e("br"),t._v("\npost：向服务端提交数据"),e("br"),t._v("\nput：修改数据"),e("br"),t._v("\nhead：请求首部（获取元信息）"),e("br"),t._v("\ndelete：删除资源"),e("br"),t._v("\nconnect：建立链接，通常用于代理"),e("br"),t._v("\noptions：列出可请求的方法，通常用来查看是否可跨域（试探一步）")]),t._v(" "),e("h3",{attrs:{id:"get-post-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-post-有什么区别"}},[t._v("#")]),t._v(" GET POST 有什么区别")]),t._v(" "),e("p",[t._v("通常来说的话get一般用来获取，post用来上传数据；（这玩儿完全看前后端怎么实现了，语义上确实是这样）"),e("br"),t._v("\n从"),e("strong",[t._v("参数")]),t._v("角度来说，get的请求会将请求内容都放在url中，而post会将请求内容放在请求体中；（这个其实是HTML标准中约定的，不是http的规则）"),e("br"),t._v("\n从"),e("strong",[t._v("缓存")]),t._v("的角度来说，GET请求会被浏览器主动缓存下来，而POST不会"),e("br"),t._v("\n从"),e("strong",[t._v("编码")]),t._v("的角度来说，GET只能进行URL编码，只能接受ASCII字符，而post没啥限制"),e("br"),t._v("\n从"),e("strong",[t._v("TCP")]),t._v("的角度来说，GET会一次性将报文发送出去，而POST会分两次，先发一次header部分，服务端返回100（continue）后再发body部分(当然这也要看浏览器，火狐就是一次发的)"),e("br"),t._v("\nget有长度限制，post可以比较长（早期是因为浏览器限制，现在好像也没了；有的服务器出于对性能啥的考虑，也对这个做了些限制）")]),t._v(" "),e("h2",{attrs:{id:"http状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" http状态码")]),t._v(" "),e("h3",{attrs:{id:"状态码类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态码类型"}},[t._v("#")]),t._v(" 状态码类型")]),t._v(" "),e("p",[e("strong",[t._v("状态码有以下几种：")]),e("br"),t._v("\n1xx：表示正在进行中"),e("br"),t._v("\n2xx：表示返回成功"),e("br"),t._v("\n3xx：表示重定向"),e("br"),t._v("\n4xx：表示客户端请求错误"),e("br"),t._v("\n5xx：表示服务端错误")]),t._v(" "),e("h3",{attrs:{id:"常见状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[t._v("#")]),t._v(" 常见状态码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("100：（continue）\n101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。\n\n200：成功\n201：？\n204：No content，请求成功，但是没有body体  \n\n301：永久重定向\n302：暂时重定向\n303：❔ 好像是暂时重定向，需要用get方法？\n304：未作修改（可用缓存）\n\n400：客户端错误\n401：权限不足\n403：Forbidden 禁止访问\n404：Not Found 查找不到\n429：Too Many Request  客户端发送的请求过多。\n\n500：Internal Server Error 服务端错误\n502：Bad Gateway 服务器正常但请求出错（网关出错？）\n503：Service Unavailable 服务器内部错误\n")])])]),e("h2",{attrs:{id:"http特点-优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http特点-优缺点"}},[t._v("#")]),t._v(" http特点（优缺点）")]),t._v(" "),e("p",[e("strong",[t._v("优点：")]),e("br"),t._v("\n1. 灵活可扩展\n2. 可靠传输：用的是TCP/IP协议\n3. 请求——应答：一收一发，有来有回")]),t._v(" "),e("p",[e("strong",[t._v("缺点：")]),e("br"),t._v("\n1. 无状态\n2. 明文传输：传输不加密，明文可见\n3. 对头阻塞：长连接只能公用一个TCP，当前请求过长就会阻塞")]),t._v(" "),e("h2",{attrs:{id:"accept-系列字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#accept-系列字段"}},[t._v("#")]),t._v(" Accept 系列字段")]),t._v(" "),e("p",[t._v("Accept系列字段的介绍分为四个部分: 数据格式（Content-Type）、压缩方式（Content-Encoding）、支持语言（Content-Language）和字符集（Accept-Charset，content的直接放在content-type中）。")]),t._v(" "),e("h2",{attrs:{id:"定长和不定长http请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定长和不定长http请求"}},[t._v("#")]),t._v(" 定长和不定长http请求")]),t._v(" "),e("p",[t._v("Content-Length, 来指明包体的长度")]),t._v(" "),e("p",[t._v("Transfer-Encoding: chunked"),e("br"),t._v("\n表示分块传输数据，设置这个字段后会自动产生两个效果:"),e("br"),t._v("\nContent-Length 字段会被忽略\n基于长连接持续推送动态内容")]),t._v(" "),e("h2",{attrs:{id:"大文件的传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大文件的传输"}},[t._v("#")]),t._v(" 大文件的传输")]),t._v(" "),e("p",[t._v("解决方式：范围请求"),e("br"),t._v("\n支持范围请求的字段： Accept-Ranges: none")]),t._v(" "),e("h2",{attrs:{id:"表单的提交"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表单的提交"}},[t._v("#")]),t._v(" 表单的提交")]),t._v(" "),e("p",[t._v("在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:\napplication/x-www-form-urlencoded\nmultipart/form-data")]),t._v(" "),e("p",[t._v("对于application/x-www-form-urlencoded格式的表单内容，有以下特点:\n其中的数据会被编码成以&分隔的键值对\n字符以URL编码方式编码。")]),t._v(" "),e("p",[t._v("对于multipart/form-data而言:\n请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。\n数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。")]),t._v(" "),e("h2",{attrs:{id:"对头阻塞问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对头阻塞问题"}},[t._v("#")]),t._v(" 对头阻塞问题")]),t._v(" "),e("p",[t._v("解决方式： 并发链接（chrom支持六个）、域名分片（一个域名下限制六个）")]),t._v(" "),e("h2",{attrs:{id:"cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" cookie")]),t._v(" "),e("p",[t._v("http是无状态的，所以一些信息使用cookie发送，cookie会在请求的时候带上")]),t._v(" "),e("blockquote",[e("p",[t._v("Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。")])]),t._v(" "),e("p",[t._v("Cookie 的缺点\n容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。\n\n安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。\n")])])]),e("h2",{attrs:{id:"http缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" http缓存")]),t._v(" "),e("p",[t._v("http的缓存分两种，一是强制缓存，一是协商缓存")]),t._v(" "),e("h3",{attrs:{id:"强制缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),e("p",[t._v("使用 cache-control 字段，可以设置如下属性"),e("br"),t._v("\n1. max-age：可以缓存的最大时间\n2. no-cache：可以在客户端存储缓存，但每次都得去服务器上校验是否最新\n3. no-store：永不使用缓存\n4. s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；\n5. public：指示响应可被任何缓存区缓存；\n6. private：只能针对个人用户，而不能被代理服务器缓存；\nExpires：过期时间，设置过期时间内的直接强制使用缓存")]),t._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("p",[t._v("协商缓存有两种字段：第一种是Etag，服务端下发Etag，客户端请求的时候带上Etag、if-None-match ；第二种是Last-modified 和 if-modified-since"),e("br"),t._v("\n当请求发起后会带上这些字段，当服务器返回304的时候表示没更新，会直接使用缓存，而当资源更新了的时候，服务器会直接返回200+新资源")]),t._v(" "),e("h4",{attrs:{id:"etag-和-last-modified区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-和-last-modified区别"}},[t._v("#")]),t._v(" Etag 和 Last-modified区别")]),t._v(" "),e("ol",[e("li",[t._v("Etag 是 hash 值，而 Last-modified 是一个时间戳  ❗ last-modified只能精确到秒")]),t._v(" "),e("li",[t._v("Etag 的优先级高于 Last-modified")])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("Last-modified 的时间戳是服务端获取的，从文件的数据：modife time获取到上次修改事件（stat / ls -al？）")])]),t._v(" "),e("h2",{attrs:{id:"跨域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),e("p",[t._v("协议、域名、端口都相同的时候才称之为同源，任意一个不符合就会发生跨域")]),t._v(" "),e("blockquote",[e("p",[t._v("跨域都是浏览器做拦截的")])]),t._v(" "),e("h3",{attrs:{id:"解决跨域的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决跨域的方式"}},[t._v("#")]),t._v(" 解决跨域的方式")]),t._v(" "),e("h4",{attrs:{id:"_1、jsonp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、jsonp"}},[t._v("#")]),t._v(" 1、jsonP")]),t._v(" "),e("p",[t._v("因为 script 标签不会没有跨域的漏洞，可以通过一个 script 标签将跨域的接口赋值给script 的src，然后通过callback执行（此方式需要服务端支持）")]),t._v(" "),e("h4",{attrs:{id:"_2、cors"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、cors"}},[t._v("#")]),t._v(" 2、CORS")]),t._v(" "),e("p",[t._v("CORS（Cross-Origin Resouce sharing），跨域资源共享，其处理方式分简单请求和复杂请求"),e("br"),t._v(" "),e("strong",[t._v("简单请求：")]),t._v(" 简单请求不会触发CORS\nAccess-Control-Allow-Origin\n条件1：使用下列方法之一：\nGET\nHEAD\nPOST\n条件2：Content-Type 的值仅限于下列三者之一：\ntext/plain\nmultipart/form-data\napplication/x-www-form-urlencoded")]),t._v(" "),e("p",[e("strong",[t._v("复杂请求")]),t._v("，简单请求之外的都是复杂请求，复杂请求会先发送一个options预检请求，如果服务端返回支持跨域，则再进行数据请求")]),t._v(" "),e("h4",{attrs:{id:"_3、websocket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、websocket"}},[t._v("#")]),t._v(" 3、websocket")]),t._v(" "),e("p",[t._v("WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。")]),t._v(" "),e("h4",{attrs:{id:"_4、nginx反向代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、nginx反向代理"}},[t._v("#")]),t._v(" 4、nginx反向代理")]),t._v(" "),e("p",[t._v("实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。")]),t._v(" "),e("h4",{attrs:{id:"_5、postmessage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、postmessage"}},[t._v("#")]),t._v(" 5、postmessage")]),t._v(" "),e("p",[t._v("postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。")]),t._v(" "),e("h2",{attrs:{id:"http2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" http2")]),t._v(" "),e("p",[t._v("http2无数量限制")]),t._v(" "),e("p",[t._v("优先级")])])}),[],!1,null,null,null);a.default=s.exports}}]);