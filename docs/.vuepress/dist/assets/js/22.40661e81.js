(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{425:function(t,a,v){"use strict";v.r(a);var r=v(20),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("blockquote",[v("p",[t._v("抛出问题\n什么是垃圾回收机制\n垃圾如何产生\n垃圾如何回收\nV8对垃圾回收做了什么优化")])]),t._v(" "),v("h2",{attrs:{id:"gc为何物"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc为何物"}},[t._v("#")]),t._v(" GC为何物")]),t._v(" "),v("p",[t._v("GC(Garbage collection)，垃圾回收机制，处理程序运行过程中产生的垃圾。")]),t._v(" "),v("h2",{attrs:{id:"垃圾产生与回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾产生与回收"}},[t._v("#")]),t._v(" 垃圾产生与回收")]),t._v(" "),v("p",[t._v("程序运行过程中会占用内存，内存占用结束后就可以被我们称为垃圾，在高级语言，如java、JavaScript、python等语言中有自动回收垃圾的机制，而在一些语言如C、C++等语言中，垃圾需要自己回收，也称为内存回收")]),t._v(" "),v("h2",{attrs:{id:"垃圾回收策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收策略"}},[t._v("#")]),t._v(" 垃圾回收策略")]),t._v(" "),v("p",[t._v("js中对于垃圾回收采用的是定期找出不再使用的内存，然后进行清理。常见的清理方法有两种：标记清除法、引用计数法")]),t._v(" "),v("h3",{attrs:{id:"标记清除法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记清除法"}},[t._v("#")]),t._v(" 标记清除法")]),t._v(" "),v("p",[t._v("标记清除法是js中最常用也是使用最广的方式。"),v("br"),t._v("\n标记清除法大致原理就是对所有的"),v("strong",[t._v("活动")]),t._v("对象进行标记，然后查询一边所有对象，将没有标记的对象清除")]),t._v(" "),v("p",[t._v("标记清除法的缺点在与清除完成后会导致内存中的空间不连续，出现空间碎片，而且随着清除的进行，碎片化会越来越严重")]),t._v(" "),v("blockquote",[v("p",[t._v("当然后面有标记整理法会规避此问题")])]),t._v(" "),v("h3",{attrs:{id:"引用计数法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[t._v("#")]),t._v(" 引用计数法")]),t._v(" "),v("p",[t._v("引用计数法现在较少使用，因为其在遇到循环引用的时候会出问题"),v("br"),t._v("\n其原理就是生成并引用的时候将其引用次数设置为1，后面没引用一次次数加一，值被覆盖一次引用减一，当这个对象的引用数量为0的时候，就任务对象不再使用了，进行回收即可")]),t._v(" "),v("p",[t._v("这种回收可以做到实时回收，但由于循环引用的存在会导致内存泄漏，并且需要一个计数器，占用空间也不小")]),t._v(" "),v("h2",{attrs:{id:"v8的gc优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8的gc优化"}},[t._v("#")]),t._v(" V8的GC优化")]),t._v(" "),v("p",[t._v("V8对于GC做了哪些优化呢"),v("br"),t._v("\n首先其使用了之前所说的标记整理法，解决了空间碎片化的问题"),v("br"),t._v("\n其次V8对与内存分新老生代区分，将一些大、老、存活时间长的对象分配于老生代，清理频率没那么高，而对那些小、新、存活时间短的新生代对象，则恰好相反(新生代通常占用1-8M内存)"),v("br"),t._v("\n并且对于新生代的内存，分为使用区和空闲区，新增的对象都放在使用区，当使用区快满时，进行一次内存清理"),v("br"),t._v("\n内存清理时，先将活动区的活动对象做标记，标记完成后将对象复制进空闲区并进行排序，当处理完成后将未标记的对象清除，然后将使用区和空闲区交换")]),t._v(" "),v("blockquote",[v("p",[t._v("如果一个对象复制到空闲区时，内存占比大于25%，则会将其直接晋升到老生代区")])]),t._v(" "),v("p",[t._v("而且V8的垃圾清理机制采用了并行回收、并发回收、增量标记（三色标记法）与懒性清理")])])}),[],!1,null,null,null);a.default=_.exports}}]);