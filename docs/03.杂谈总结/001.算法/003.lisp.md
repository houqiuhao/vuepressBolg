const expression = '(let x 2 (mult x (let x 3 y 4 (add x y))))'
const expression1 = '(let x 3 x 2 x)'
var evaluate = function(expression) {
	// 当前执行的位置 k, 作用域 field
	const runtime = (k, field = {}) => {
		let syntax = ''
		let vals = []
		let op = null
		const process = []
		while (k < expression.length) {
			switch (expression[k]) {
				case ' ':
					// 当收集的串不为空串时
					if (syntax) { // 1、let  //2、x  //3、3 //4、x
						// 若操作为null时
						if (!op) {
							// 先对操作赋值
							op = syntax // 1、op : let
							// 如果操作为let 则复制作用域
							if (op == 'let') {
								// ??? // 1、{}
								field = {
									...field
								}
							}
						} else if (op == 'let') { // 2、let //3、let
							process.push(syntax) // 2、[x]  //3、[x,3]
							// 若待处理的结果里有两个值
							if (process.length >= 2) { // 3、[x,3]
								const v = parseFloat(process[1]) // 3、3
								if (isNaN(v)) {
									// 如果值为非数，则从作用域中取得
									field[process[0]] = field[process[1]]
								} else {
									// 如果值为数字，则直接赋值
									field[process[0]] = v
								}
								// 清空待处理数组
								process.length = 0
							}
						} else {
							// 其他情况下，默认为参数
							vals.push(syntax)
						}
						syntax = ''
					}
					++k
					break
				case '(':
					// 当遇到左括号时，递归处理子式
					const returns = runtime(k + 1, field)
					// 如果操作为let
					if (op == 'let') {
						// 对作用域赋值进行处理
						process.push(returns[0])
						if (process.length >= 2) {
							field[process[0]] = parseFloat(process[1])
							process.length = 0
						}
					}
					// 保存子式的结果
					vals.push(returns[0])
					// 刷新当前处理的字符串的右边界
					k = returns[1]
					break
				case ')':
					// 当遇到右括号时计算子式的值
					if (syntax) vals.push(syntax)
					// 转换参数列表里面的值
					vals = vals.map(val => isNaN(parseFloat(val)) ? field[val] : val)
					// 对不同的操作执行不同的方法
					switch (op) {
						case 'add':
							// 相加
							const add = parseFloat(vals[0]) + parseFloat(vals[1])
							return [add, k + 1]
						case 'mult':
							// 相乘
							const mult = parseFloat(vals[0]) * parseFloat(vals[1])
							return [mult, k + 1]
						case 'let':
							// 当操作为let时直接返回最后一个参数的值
							return [vals[vals.length - 1], k + 1]
					}
					break
				default:
					// 其余情况下，收集字符形成字符串
					syntax += expression[k++]
			}
		}
		return vals[0]
	}

	return runtime(0)
}

var evaluate = function(expression) {
	const runtime = (k, field = {}) => {
		let syntax = ''
		let vals = []
		let op = null
		const process = []
		while (k < expression.length) {
			switch (expression[k]) {
				case ' ':
					if (syntax) {
						if (!op) {
							op = syntax
							if (op == 'let') {
								field = {
									...field
								}
							}
						} else if (op == 'let') {
							process.push(syntax)
							if (process.length >= 2) {
								const v = parseFloat(process[1])
								if (isNaN(v)) {
									field[process[0]] = field[process[1]]
								} else {
									field[process[0]] = v
								}
								process.length = 0
							}
						} else {
							vals.push(syntax)
						}
						syntax = ''
					}
					++k
					break
				case '(':
					const returns = runtime(k + 1, field)
					// 如果操作为let
					if (op == 'let') {
						process.push(returns[0])
						if (process.length >= 2) {
							field[process[0]] = parseFloat(process[1])
							process.length = 0
						}
					}
					vals.push(returns[0])
					k = returns[1]
					break
				case ')':
					if (syntax) vals.push(syntax)
					vals = vals.map(val => isNaN(parseFloat(val)) ? field[val] : val)
					switch (op) {
						case 'add':
							const add = parseFloat(vals[0]) + parseFloat(vals[1])
							return [add, k + 1]
						case 'mult':
							const mult = parseFloat(vals[0]) * parseFloat(vals[1])
							return [mult, k + 1]
						case 'let':
							return [vals[vals.length - 1], k + 1]
					}
					break
				default:
					syntax += expression[k++]
			}
		}
		return vals[0]
	}
	return runtime(0)
}

var evaluate = function(expression) {
	// 语法树节点
	function SyntaxNode(type) {
		const STDNAME = /^[a-zA-Z\$_][a-zA-Z\d_]*$/
		this.type = type
		this.catholic = []
		this.names = []
		this.addNext = (x) => {
			if (x instanceof SyntaxNode) {
				this.catholic.push(x)
			} else if (STDNAME.test(x)) {
				const name_node = new SyntaxNode(Symbol.for('name'))
				name_node.catholic.push(x)
				this.catholic.push(name_node)
			} else {
				const num_node = new SyntaxNode(Symbol.for('number'))
				num_node.catholic.push(x)
				this.catholic.push(num_node)
			}
			if (type == Symbol.for('Dec')) {
				if (this.catholic.length >= 2) {
					const value = this.catholic.pop()
					const key = this.catholic.pop()
					if (key.type == Symbol.for('name')) {
						const c = new SyntaxNode(Symbol.for('C'))
						c.addNext(key)
						c.addNext(value)
						this.catholic.push(c)
					} else {
						this.catholic.push(key)
						this.catholic.push(value)
					}
				}
			}
		}
		this.process = (field = {}) => {
			const vals = this.catholic
			switch (type) {
				case Symbol.for('Add'):
					return vals[0].process(field) + vals[1].process(field)
				case Symbol.for('Mult'):
					return vals[0].process(field) * vals[1].process(field)
				case Symbol.for('Exp'):
					return vals[0].process(field)
				case Symbol.for('Dec'):
					for (const e of vals) {
						if (e.type == Symbol.for('C')) {
							const p = e.process(field)
							field = { ...field, ...{ [p.k]: p.v }}
						}
					}
					return vals[vals.length - 1].process({ ...field })
				case Symbol.for('C'):
					return { k: vals[0].catholic[0], v: vals[1].process(field) }
				case Symbol.for('name'):
					return field[vals[0]]
				case Symbol.for('number'):
					return parseFloat(vals[0])
			}
		}
		this.display = (blanks = 0) => {
			console.log(' '.repeat(blanks) + type.toString())
			for (const e of this.catholic) {
				if (e instanceof SyntaxNode) {
					e.display(blanks + 2)
				} else {
					console.log(' '.repeat(blanks) + e)
				}
			}
		}
	}

	// 构造语法树
	function generateSyntaxTree(exp, k) {
		let syntax = ''; let node = null
		while (k < exp.length) {
			switch (exp[k]) {
				case '(':
					const returns = generateSyntaxTree(exp, k + 1)
					if (node) {
						const cache = new SyntaxNode(Symbol.for('Exp'))
						cache.addNext(returns[0])
						node.addNext(cache)
						k = returns[1] + 1
					} else {
						node = new SyntaxNode(Symbol.for('Exp'))
						node.addNext(returns[0])
						k = returns[1]
					}
					break
				case ' ':
					if (!syntax) {
						++k
						break
					}
					switch (syntax) {
						case 'add':
							node = new SyntaxNode(Symbol.for('Add'))
							break
						case 'mult':
							node = new SyntaxNode(Symbol.for('Mult'))
							break
						case 'let':
							node = new SyntaxNode(Symbol.for('Dec'))
							break
						default:
							node.addNext(syntax)
							break
					}
					syntax = '', ++k
					break
				case ')':
					if (syntax && node) node.addNext(syntax)
					return [node, k]
				default:
					syntax += exp[k++]
					break
			}
		}
		if (!node) throw new Error('parsing fail.')
		return [node, k]
	}

	const root = generateSyntaxTree(expression, 0)[0]
	// root.display();
	return root.process()
}