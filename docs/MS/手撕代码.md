##
### 数组去重
    1、Array.from(new Set())
    2. for循环 + indexOf() + push
    3. for循环 + includes（）+push
    4. fliter + indexOf（）
    5. 双重for循环加splice

### 斐波那契数列
```js
    //方法1 递归改进
    function fibonacci(n) {
        function fib (n,v1,v2) {
            if(n === 1) {
                return v1
            }
            if(n === 2) {
                return v2
            }
            return fib(n-1, v2, v1+v2)
        }
        return fib(n, 1,1)
    }
    //还可以使用for循环+解构赋值
```

### 计算数组交集并集补集等
    1、使用filter + indexOf（）
    2、通用api，a与b的交集：Array.intersect(a, b)
            a与b的差集： Array.minus(a, b)
            a与b的补集： Array.complement(a, b)
            a与b的并集： Array.union(a, b)
    3、Set + filter + has + ...   
        // 补集
        let complement = [...a.filter(x => !sb.has(x)), ...b.filter(x => !sa.has(x))];

### 手写防抖节流
```js
    //防抖
    function debounce(fn,wait) {
        let timeout = null
        return function () {
            if(timeout !== null){
                clearTimeout(timeout);
                timeout = setTimeout(fn,wait)
            }
        }
    }
    //节流
    function throttle(func, delay) {
        var timer = null
        var startTime = Date.new()
        return function () {
            let currTime = Date.new()
            let remaining = delay - (currTime - startTime)
            let context = this
            let args = arguments
            clearTimeout(timer)
            if(remaining <= 0) {
                func.apply(context, args)
                startTime = Date.new()
            } else {
                timer = setTimeout(func, remaining)
            }
        }
    }
```

### 实现 call apply bind
```js
    Function.prototype.myCall = function(context) {
        var context = context || window
        context.fn = this
        var args = [...arguments].slice(1)
        var result = context.fn(...args)
        delete context.fn
        return result
    }
    Function.prototype.myapply = function(context) {
	var context = context || window;

	context.fn = this;

	var result = null;

	if(arguments[1]) {
	
		result = context.fn(...arguments);
		
	}else {
	
		result = context.fn();
		
	}
	
	delete context.fn;

	return result;
}

Function.prototype.mybind = function(context) {
	if(typeof this !== 'function') {
	
		throw new TypeError('Error');
		
	}
	
	var _this = this;

	var args = [...arguments].slice(1);

	return function F() {
	
		if(this instanceof F) {
		
			return new _this(...args, ...arguments);
			
		}
		
		return _this.apply(context, args.concat(...arguments));
		
	}
}
```


### js继承
```js
//首先写出父级
function Animal (name) {
    this.name = name || 'Animal'
    this.sleep = function () {
        console.log(this.name + 'sleepping')
    }
}
//原型链继承,简单，无法多继承，所有共享
function Cat () {
}
Cat.prototype = new Animal()
Cat.prototype.name = 'cat'
// 构造继承，实例是子类的实例，只能继承实例属性方法，不能继承原型方法
function Cat (name) {
    Animal.call(this);
    this.name = name || 'tom';
}
//实例继承，实例是父类的，不能多继承
function Cat (name) {
    var instance = new Animal()
    instance.name = name || 'tom'
    return instance
}
//拷贝继承，占内存高
function Cat (name) {
    var animal = new Animal()
    for (var p in animal){
        Cat.prototype[p] = animal[p]
    }
    this.name = name || 'tom'
}
//组合继承，调用了两次父类构造函数，生成了两份实例
function Cat (name) {
    Animal.call(this);
    this.name = name || 'tom'
}
Cat.prototype = new Animal()
Cat.prototype.constructor = Cat
//寄生组合继承
function Cat(name){
    Animal.call(this);
    this.name = name || 'tom'
}
(function () {
    var Super = funciton(){}
    Super.prototype = Animal.prototype;
    Cat.prototype = new Super()
})
```

### 手写new
```js
    function _new(fn,...args){
        const obj = Object.create(fn.prototype)
        const res = fn.apply(obj,args)
        return rel instanceof Object ? res : obj
    }
```
### 手写promise


```js
/*
 * pending:初始化成功
 * fulfilled:成功
 * rejected：失败
 * */

function Promise(executor) {// 执行器
    this.status = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.fulfilledCallback = [];
    this.rejectCallback = [];
    let resolve = (value)=>{
        if(this.status=='pending'){
            this.status = 'resolve';
            this.value = value;
            this.fulfilledCallback.forEach(fn=>fn())
        }
    };
    let reject = (reason)=>{
        if(this.status =='pending'){
            this.status = 'reject';
            this.reason = reason;
            this.rejectCallback.forEach(fn=>fn())
        }
    };
    try{
        executor(resolve,reject)
    }catch(e){
        reject(e)
    }
}
Promise.prototype.then = function (onfulfilled,onrejected) {
    if(this.status == 'resolve'){
        onfulfilled(this.value)
    }
    if(this.status == 'reject'){
        onrejected(this.reason)
    }
    if(this.status == 'pending'){
        this.fulfilledCallback.push(()=>{
            onfulfilled(this.value)
        });
        this.rejectCallback.push(()=>{
            onrejected(this.reason)
        })
    }
};

var a = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(10)
    })
});
a.then((res)=>{
    console.log(res);
});
```

### 一维数组变多维