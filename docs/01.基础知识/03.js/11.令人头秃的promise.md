---
title: ä»¤äººå¤´ç§ƒçš„promise
date: 2022-02-16 21:48:54
permalink: /pages/a7c3cf/
sidebar: auto
categories:
  - åŸºç¡€çŸ¥è¯†
  - js
tags:
  - 
---

## ç¼˜èµ·
> **è¯ä¸å¤šè¯´ å…ˆä¸Šå¤´**
```js
//çŒœçŒœå®ƒçš„è¾“å‡ºï¼Ÿ
Promise.resolve().then(() => {
    console.log(0);
    return Promise.resolve(4);
}).then((res) => {
    console.log(res)
})

Promise.resolve().then(() => {
    console.log(1);
}).then(() => {
    console.log(2);
}).then(() => {
    console.log(3);
}).then(() => {
    console.log(5);
}).then(() =>{
    console.log(6);
})
// è¿™ä»–å¨˜çš„è¾“å‡ºæ˜¯ 0 1 2 3 4 5 6 
// ä¸åº”è¯¥æ˜¯ 0 1 4 2 3â€¦â€¦å—ï¼Ÿï¼Ÿï¼Ÿ
// ä¸€ä¸ªå›ç­”ï¼šJså¼•æ“ä¸ºäº†è®©microtaskå°½å¿«çš„è¾“å‡ºï¼Œåšäº†ä¸€äº›ä¼˜åŒ–
// è¿ç»­çš„å¤šä¸ªthen(3ä¸ª)å¦‚æœæ²¡æœ‰rejectæˆ–è€…resolveä¼šäº¤æ›¿æ‰§è¡Œthenè€Œä¸è‡³äºè®©ä¸€ä¸ªå µå¤ªä¹…å®Œæˆç”¨æˆ·æ— å“åº”
// ä¸å•å•v8è¿™æ ·å…¶ä»–å¼•æ“ä¹Ÿæ˜¯è¿™æ ·ï¼Œå› ä¸ºå…¶å®promuseå†…éƒ¨çŠ¶æ€å·²ç»ç»“æŸäº†
```

### å®ä»»åŠ¡å’Œå¾®ä»»åŠ¡
jsæœ‰ä¸¤ç§ä»»åŠ¡çš„æ‰§è¡Œæ¨¡å¼ï¼š**åŒæ­¥**å’Œ**å¼‚æ­¥**  
å¼‚æ­¥ä¸­åˆåˆ†ä¸ºä¸¤ç§ï¼Œå¾®ä»»åŠ¡Microtaskï¼ˆå’Œå®ä»»åŠ¡ï¼ˆMacrotaskï¼‰ï¼Œå®ä»»åŠ¡æ˜¯ç”±å®¿ä¸»ï¼ˆæµè§ˆå™¨ï¼ŒNodeï¼‰å‘èµ·çš„ï¼Œè€Œå¾®ä»»åŠ¡æ˜¯ç”±jsè‡ªèº«å‘èµ·;å®ä»»åŠ¡ä¼šåœ¨ä¸‹æ¬¡äº‹ä»¶å¾ªç¯å¼€å§‹çš„æ—¶å€™æ‰§è¡Œï¼Œå¾®ä»»åŠ¡ä¼šåœ¨æ­¤æ¬¡äº‹ä»¶å¾ªç¯ä¸­åŒæ­¥ä»»åŠ¡ç»“æŸåæ‰§è¡Œ  

| **å®ä»»åŠ¡**(Macrotas) | **å¾®ä»»åŠ¡**(Microtask)           |
|      ----            |         ----                     |
|     setTimeout       |  requestAnimationFrameï¼ˆæœ‰äº‰è®®ï¼‰ |
|      setInterval     |    MutationObserverï¼ˆæµè§ˆå™¨ç¯å¢ƒï¼‰|
|    MessageChannel    |  Promise.[ then/catch/finally ]  |
|     I/Oï¼Œäº‹ä»¶é˜Ÿåˆ—    |   process.nextTickï¼ˆNodeç¯å¢ƒï¼‰   |
|setImmediateï¼ˆNodeç¯å¢ƒï¼‰|       queueMicrotask           |
|scriptï¼ˆæ•´ä½“ä»£ç å—ï¼‰  |                                  |


## æ‰‹æ’•Promise
æˆ‘ä»¬ä½¿ç”¨çš„ Promise æ˜¯åŸºäº Promise A+ è§„èŒƒå®ç°çš„  
::: cardList 1
```yaml
- name: Promise A+ è§„èŒƒ
  desc: ğŸš€ç‚¹å‡»æŸ¥çœ‹Promise A+ çš„å®˜æ–¹è§„èŒƒ
  link: https://promisesaplus.com/
  bgColor: '#DFEEE7'
  textColor: '#2A3344'
```
:::


flow æ˜é‡‘ **ITè€ç­é•¿**å¤§ä½¬çš„æ–‡ç« å­¦ç€æ‰‹å†™ä¸€ç‰ˆï¼Œ**å¤§ä½¬è¯´é“**ï¼šå¾ˆå¤šæ‰‹å†™ç‰ˆæœ¬éƒ½æ˜¯ä½¿ç”¨ setTimeout å»åšå¼‚æ­¥å¤„ç†ï¼Œä½†æ˜¯ setTimeout å±äºå®ä»»åŠ¡ï¼Œè¿™ä¸ Promise æ˜¯ä¸ªå¾®ä»»åŠ¡ç›¸çŸ›ç›¾ï¼Œæ‰€ä»¥æ‰“ç®—é€‰æ‹©ä¸€ç§åˆ›å»ºå¾®ä»»åŠ¡çš„æ–¹å¼å»å®ç°æˆ‘ä»¬çš„æ‰‹å†™ä»£ç ã€‚  
è¿™é‡Œæˆ‘ä»¬æœ‰å‡ ç§é€‰æ‹©ï¼Œä¸€ç§å°±æ˜¯ Promise A+ è§„èŒƒä¸­ä¹Ÿæåˆ°çš„ï¼Œprocess.nextTickï¼ˆ Node ç«¯ ï¼‰ ä¸MutationObserverï¼ˆ æµè§ˆå™¨ç«¯ ï¼‰ï¼Œè€ƒè™‘åˆ°åˆ©ç”¨è¿™ä¸¤ç§æ–¹å¼éœ€è¦åšç¯å¢ƒåˆ¤æ–­ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œæˆ‘ä»¬å°±æ¨èå¦å¤–ä¸€ç§åˆ›å»ºå¾®ä»»åŠ¡çš„æ–¹å¼ queueMicrotask  

    åŸºæœ¬åŸç†ï¼š
    1. Promise æ˜¯ä¸€ä¸ªç±»ï¼Œåœ¨æ‰§è¡Œè¿™ä¸ªç±»çš„æ—¶å€™ä¼šä¼ å…¥ä¸€ä¸ªæ‰§è¡Œå™¨ï¼Œè¿™ä¸ªæ‰§è¡Œå™¨ä¼šç«‹å³æ‰§è¡Œ
    2. Promise ä¼šæœ‰ä¸‰ç§çŠ¶æ€
        Pending ç­‰å¾…
        Fulfilled å®Œæˆ
        Rejected å¤±è´¥
    3. çŠ¶æ€åªèƒ½ç”± Pending --> Fulfilled æˆ–è€… Pending --> Rejectedï¼Œä¸”ä¸€ä½†å‘ç”Ÿæ”¹å˜ä¾¿ä¸å¯äºŒæ¬¡ä¿®æ”¹ï¼›
    4. Promise ä¸­ä½¿ç”¨ resolve å’Œ reject ä¸¤ä¸ªå‡½æ•°æ¥æ›´æ”¹çŠ¶æ€ï¼›
    5. then æ–¹æ³•å†…éƒ¨åšä½†äº‹æƒ…å°±æ˜¯çŠ¶æ€åˆ¤æ–­
        å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸï¼Œè°ƒç”¨æˆåŠŸå›è°ƒå‡½æ•°
        å¦‚æœçŠ¶æ€æ˜¯å¤±è´¥ï¼Œè°ƒç”¨å¤±è´¥å›è°ƒå‡½æ•°
### ä¸€ã€æ ¸å¿ƒç®€å•å®ç°
```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        executor(this.resolve,this.reject)
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING

    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null

    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡

    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
        if(this.status === FULFILLED) {
            // è°ƒç”¨å‡½æ•°
            onFulfilled(this.value)
        } else if (this.status === REJECTED) {
            onRejected(this.reason)
        }
    }


}
module.exports = MyPromise
```

ä¸Šé¢ä»£ç å¯ä»¥å®ç°ç®€å•çš„æ–°å»ºpromiseäº†å¯ä»¥ç”¨å¦‚ä¸‹ä»£ç æµ‹è¯•ï¼š
```js
const promise = new MyPromise((resolve, reject) => {
   resolve('success')
   reject('err')
})

promise.then(value => {
  console.log('resolve', value)
}, reason => {
  console.log('reject', reason)
})
// æ‰§è¡Œç»“æœï¼šresolve success
```
### äºŒã€æ·»åŠ å¼‚æ­¥å¤„ç†
ä½†æ˜¯å¦‚æœå¤šæµ‹è¯•ä¸‹å°±å‘ç°è§£å†³ä¸äº†å¼‚æ­¥é—®é¢˜ï¼Œæ‰€ä»¥ç»§ç»­åŠ 

```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        executor(this.resolve,this.reject)
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING
    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null
    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // å¼‚æ­¥æ–°å¢
    // ç¼“å­˜æˆåŠŸå›è°ƒå‡½æ•°
    onFulfilledCallback = null
    // ç¼“å­˜å¤±è´¥å›è°ƒå‡½æ•°
    onRejectedCallback = null


    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡
    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
            // è°ƒç”¨å›è°ƒå‡½æ•°
            this.onFulfilledCallback && this.onFulfilledCallback(value)
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
            // è°ƒç”¨å›è°ƒå‡½æ•°
            this.onRejectedCallback && this.onRejectedCallback(reason)
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
        if(this.status === FULFILLED) {
            // è°ƒç”¨å‡½æ•°
            onFulfilled(this.value)
        } else if (this.status === REJECTED) {
            onRejected(this.reason)
        } else if (this.status === PENDING) {
            // æ·»åŠ pendingæ—¶å€™çš„å¤„ç†
            this.onFulfilledCallback = onFulfilled
            this.onRejectedCallback = onFulfilled
        }    
    }


}
module.exports = MyPromise
```

### ä¸‰ã€thenæ–¹æ³•å¤šæ¬¡è°ƒç”¨æ·»åŠ å¤šä¸ªå¤„ç†å‡½æ•°
```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        executor(this.resolve,this.reject)
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING
    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null
    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // thenä¿®æ”¹ éœ€è¦ä¸ºæ•°ç»„
    // ç¼“å­˜æˆåŠŸå›è°ƒå‡½æ•°
    onFulfilledCallback = []
    // ç¼“å­˜å¤±è´¥å›è°ƒå‡½æ•°
    onRejectedCallback = []


    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡
    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onFulfilledCallback.length){
                this.onFulfilledCallback.shift()(value)
                
            }
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onRejectedCallback.length) {
                this.onRejectedCallback.shift()(reason)

            }
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
        if(this.status === FULFILLED) {
            // è°ƒç”¨å‡½æ•°
            onFulfilled(this.value)
        } else if (this.status === REJECTED) {
            onRejected(this.reason)
        } else if (this.status === PENDING) {
            // æ·»åŠ pendingæ—¶å€™çš„å¤„ç†
            this.onFulfilledCallback.push(onFulfilled)
            this.onRejectedCallback.push(onFulfilled)
        }    
    }
}
module.exports = MyPromise
```

### å››ã€thenæ–¹æ³•çš„é“¾å¼è°ƒç”¨ && äº”ã€thené“¾å¼è°ƒç”¨è¯†åˆ«Promiseæ˜¯å¦è¿”å›è‡ªå·± && å…­ã€é”™è¯¯æ•è·
    then æ–¹æ³•è¦é“¾å¼è°ƒç”¨é‚£ä¹ˆå°±éœ€è¦è¿”å›ä¸€ä¸ª Promise å¯¹è±¡
    then æ–¹æ³•é‡Œé¢ return ä¸€ä¸ªè¿”å›å€¼ä½œä¸ºä¸‹ä¸€ä¸ª then æ–¹æ³•çš„å‚æ•°ï¼Œå¦‚æœæ˜¯ return ä¸€ä¸ª Promise å¯¹è±¡ï¼Œé‚£ä¹ˆå°±éœ€è¦åˆ¤æ–­å®ƒçš„çŠ¶æ€
    -------------------------------------------------------------------------------
    å¦‚æœ then æ–¹æ³•è¿”å›çš„æ˜¯è‡ªå·±çš„ Promise å¯¹è±¡ï¼Œåˆ™ä¼šå‘ç”Ÿå¾ªç¯è°ƒç”¨ï¼Œè¿™ä¸ªæ—¶å€™ç¨‹åºä¼šæŠ¥é”™
```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        try {
            executor(this.resolve,this.reject)
        } catch (error) {
            this.reject(error)
        }
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING
    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null
    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // thenä¿®æ”¹ éœ€è¦ä¸ºæ•°ç»„
    // ç¼“å­˜æˆåŠŸå›è°ƒå‡½æ•°
    onFulfilledCallback = []
    // ç¼“å­˜å¤±è´¥å›è°ƒå‡½æ•°
    onRejectedCallback = []


    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡
    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onFulfilledCallback.length){
                this.onFulfilledCallback.shift()(value)
                
            }
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onRejectedCallback.length) {
                this.onRejectedCallback.shift()(reason)

            }
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    // ===æ–°å¢===
    // é“¾å¼è°ƒç”¨å°±å¾—è¿”å›promise åˆ¤æ–­çŠ¶æ€è¿›è¡Œå¤„ç†
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // === æ–°å¢ ===
        // å…ˆåˆ›å»ºpromise
        const promise2 = new MyPromise((resolve,reject) => {
            // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
            if(this.status === FULFILLED) {
                // è°ƒç”¨å‡½æ•°
                // ä¿å­˜è¿”å›çš„å¤„ç†å€¼

                // äº”ã€éœ€è¦åˆ›å»ºå¾®ä»»åŠ¡ç­‰å¾…promise2åˆ›å»ºå®Œæ¯•
                queueMicrotask(() => {
                    try {
                        const x = onFulfilled(this.value)
                        // ç”¨ä¸€ä¸ªå‡½æ•°å¤„ç†å€¼ï¼Œéœ€è¦åˆ¤æ–­æ˜¯promiseè¿˜æ˜¯æ™®é€šå‡½æ•°
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(error) {
                        //! è°ƒç”¨çš„ä¼ å…¥çš„reject è€Œä¸æ˜¯this.reject
                        reject(error)
                    }
                })
            } else if (this.status === REJECTED) {
                onRejected(this.reason)
            } else if (this.status === PENDING) {
                // æ·»åŠ pendingæ—¶å€™çš„å¤„ç†
                this.onFulfilledCallback.push(onFulfilled)
                this.onRejectedCallback.push(onFulfilled)
            }
        })
        // ï¼ï¼è¦å°†promise2 returnå‡ºæ¥
        return promise2
    }
}
// === æ–°å¢ ===
// åˆ›å»ºå‡½æ•°å¤„ç†promise
function resolvePromise (promise2, x, resolve, reject) {
    // å¦‚æœç›¸ç­‰äº†ï¼Œè¯´æ˜returnçš„æ˜¯è‡ªå·±ï¼ŒæŠ›å‡ºç±»å‹é”™è¯¯å¹¶è¿”å›
    if (promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
    }
    // åˆ¤æ–­æ˜¯å¦promise
    if(x instanceof MyPromise) {
        // æ‰§è¡Œ xï¼Œè°ƒç”¨ then æ–¹æ³•ï¼Œç›®çš„æ˜¯å°†å…¶çŠ¶æ€å˜ä¸º fulfilled æˆ–è€… rejected
        // x.then(value => resolve(value), reason => reject(reason))
        // ç®€åŒ–ä¹‹å
        x.then(resolve, reject)
    } else {
        // æ™®é€šå€¼
        resolve(x)
    }
}
module.exports = MyPromise
```

### ä¸ƒã€è€ƒè™‘fufilledçŠ¶æ€ä¸‹çš„å¤„ç†ï¼Œå¯¹rejected å’Œpendingæ”¹é€ 
    å¢åŠ å¼‚æ­¥çŠ¶æ€ä¸‹çš„é“¾å¼è°ƒç”¨
    å¢åŠ å›è°ƒå‡½æ•°æ‰§è¡Œç»“æœçš„åˆ¤æ–­
    å¢åŠ è¯†åˆ« Promise æ˜¯å¦è¿”å›è‡ªå·±
    å¢åŠ é”™è¯¯æ•è·

```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        try {
            executor(this.resolve,this.reject)
        } catch (error) {
            this.reject(error)
        }
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING
    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null
    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // thenä¿®æ”¹ éœ€è¦ä¸ºæ•°ç»„
    // ç¼“å­˜æˆåŠŸå›è°ƒå‡½æ•°
    onFulfilledCallback = []
    // ç¼“å­˜å¤±è´¥å›è°ƒå‡½æ•°
    onRejectedCallback = []


    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡
    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onFulfilledCallback.length){
                this.onFulfilledCallback.shift()(value)
                
            }
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onRejectedCallback.length) {
                this.onRejectedCallback.shift()(reason)

            }
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    // ===æ–°å¢===
    // é“¾å¼è°ƒç”¨å°±å¾—è¿”å›promise åˆ¤æ–­çŠ¶æ€è¿›è¡Œå¤„ç†
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // === æ–°å¢ ===
        // å…ˆåˆ›å»ºpromise
        const promise2 = new MyPromise((resolve,reject) => {
            // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
            if(this.status === FULFILLED) {
                // è°ƒç”¨å‡½æ•°
                // ä¿å­˜è¿”å›çš„å¤„ç†å€¼

                // äº”ã€éœ€è¦åˆ›å»ºå¾®ä»»åŠ¡ç­‰å¾…promise2åˆ›å»ºå®Œæ¯•
                queueMicrotask(() => {
                    try {
                        const x = onFulfilled(this.value)
                        // ç”¨ä¸€ä¸ªå‡½æ•°å¤„ç†å€¼ï¼Œéœ€è¦åˆ¤æ–­æ˜¯promiseè¿˜æ˜¯æ™®é€šå‡½æ•°
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(error) {
                        //! è°ƒç”¨çš„ä¼ å…¥çš„reject è€Œä¸æ˜¯this.reject
                        reject(error)
                    }
                })
            } else if (this.status === REJECTED) {
                // åŒä¸Šé¢ å¢åŠ å¾®ä»»åŠ¡
                queueMicrotask(() => {
                    try {
                        const x = onRejected(this.reason)
                        // ç”¨ä¸€ä¸ªå‡½æ•°å¤„ç†å€¼ï¼Œéœ€è¦åˆ¤æ–­æ˜¯promiseè¿˜æ˜¯æ™®é€šå‡½æ•°
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(error) {
                        //! è°ƒç”¨çš„ä¼ å…¥çš„reject è€Œä¸æ˜¯this.reject
                        reject(error)
                    }
                })
            } else if (this.status === PENDING) {
                // æ·»åŠ pendingæ—¶å€™çš„å¤„ç†
                // === æ–°å¢ ===
                // ===éœ€è¦pushè¿›å»çš„åº”è¯¥æ˜¯å¾®ä»»åŠ¡===
                this.onFulfilledCallback.push(() => {
                    queueMicrotask(() => {
                        try {
                            // è·å–æˆåŠŸå›è°ƒå‡½æ•°çš„æ‰§è¡Œç»“æœ
                            const x = onFulfilled(this.value);
                            // ä¼ å…¥ resolvePromise é›†ä¸­å¤„ç†
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (error) {
                            reject(error)
                        }
                    })
                })
                this.onRejectedCallback.push(() => {
                    queueMicrotask(() => {
                        try {
                            // è°ƒç”¨å¤±è´¥å›è°ƒï¼Œå¹¶ä¸”æŠŠåŸå› è¿”å›
                            const x = onRejected(this.reason);
                            // ä¼ å…¥ resolvePromise é›†ä¸­å¤„ç†
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (error) {
                            reject(error)
                        }
                    })
                })
            }
        })
        // ï¼ï¼è¦å°†promise2 returnå‡ºæ¥
        return promise2
    }
}
// åˆ›å»ºå‡½æ•°å¤„ç†promise
function resolvePromise (promise2, x, resolve, reject) {
    // å¦‚æœç›¸ç­‰äº†ï¼Œè¯´æ˜returnçš„æ˜¯è‡ªå·±ï¼ŒæŠ›å‡ºç±»å‹é”™è¯¯å¹¶è¿”å›
    if (promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
    }
    // åˆ¤æ–­æ˜¯å¦promise
    if(x instanceof MyPromise) {
        // æ‰§è¡Œ xï¼Œè°ƒç”¨ then æ–¹æ³•ï¼Œç›®çš„æ˜¯å°†å…¶çŠ¶æ€å˜ä¸º fulfilled æˆ–è€… rejected
        // x.then(value => resolve(value), reason => reject(reason))
        // ç®€åŒ–ä¹‹å
        x.then(resolve, reject)
    } else {
        // æ™®é€šå€¼
        resolve(x)
    }
}
module.exports = MyPromise
```


### å…«ã€thenä¸­çš„å‚æ•°å˜ä¸ºå¯é€‰ && ä¹ã€resolve å’Œ rejectçš„é™æ€è°ƒç”¨
åŸç”Ÿpromise then ä¸ä¼ é€’å›è°ƒå‡½æ•°ä¹Ÿæ˜¯å¯ä»¥ç”¨çš„
```js
const FULFILLED = 'fulfilled'
const PENDING = 'pending'
const REJECTED = 'rejected'
class MyPromise {
    //æ„é€ å‡½æ•°
    constructor(executor){
        //ç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œexecutoræ˜¯æ‰§è¡Œå™¨
        try {
            executor(this.resolve,this.reject)
        } catch (error) {
            this.reject(error)
        }
    }
    // æœ€å¼€å§‹çš„çŠ¶æ€æ˜¯PENDING
    status = PENDING
    // æˆåŠŸåçš„å€¼ åˆå§‹ä¸ºç©º
    value = null
    // å¤±è´¥åçš„åŸå›  åˆå§‹ä¸ºç©º
    reason = null

    // thenä¿®æ”¹ éœ€è¦ä¸ºæ•°ç»„
    // ç¼“å­˜æˆåŠŸå›è°ƒå‡½æ•°
    onFulfilledCallback = []
    // ç¼“å­˜å¤±è´¥å›è°ƒå‡½æ•°
    onRejectedCallback = []


    // resolveå’Œrejectä¸ºä»€ä¹ˆè¦ç”¨ç®­å¤´å‡½æ•°ï¼Ÿ
    // å¦‚æœç›´æ¥è°ƒç”¨çš„è¯ï¼Œæ™®é€šå‡½æ•°thisæŒ‡å‘çš„æ˜¯windowæˆ–è€…undefined
    // ç”¨ç®­å¤´å‡½æ•°å°±å¯ä»¥è®©thisæŒ‡å‘å½“å‰å®ä¾‹å¯¹è±¡
    // æ›´æ”¹æˆåŠŸåçš„çŠ¶æ€
    resolve = (value) => {
        //æˆåŠŸåçŠ¶æ€ä¼šè¾¹ä¸ºfulfilled
        // !åªæœ‰çŠ¶æ€ä¸ºpendingæ‰èƒ½æ›´æ”¹çŠ¶æ€
        if(this.status === PENDING) {
            this.status = FULFILLED
            // æˆåŠŸåè¿”å›å€¼
            // ï¼ä¿å­˜æˆåŠŸçš„è¿”å›å€¼
            this.value = value
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onFulfilledCallback.length){
                this.onFulfilledCallback.shift()(value)
                
            }
        }
    }
    // æ›´æ”¹å¤±è´¥åçš„çŠ¶æ€
    reject = (reason) =>{
        // æ›´æ–°å¤±è´¥åçš„çŠ¶æ€
        // åªèƒ½æ”¹å˜pendingçš„çŠ¶æ€
        if(this.status === PENDING) {
            this.status = REJECTED
            // è¿”å›å¤±è´¥åŸå› 
            // !ä¿å­˜å¤±è´¥çš„åŸå› 
            this.reason = reason
            // è°ƒç”¨å›è°ƒå‡½æ•°
            // ä¿®æ”¹è°ƒç”¨
            while(this.onRejectedCallback.length) {
                this.onRejectedCallback.shift()(reason)

            }
        }
    }
    // å¤„ç†then 
    // ï¼THENæ˜¯ä¸ªå‡½æ•°ï¼Œä¸”ä¼šå¤„ç†onFulfilledå’ŒonRejected
    // ===æ–°å¢===
    // é“¾å¼è°ƒç”¨å°±å¾—è¿”å›promise åˆ¤æ–­çŠ¶æ€è¿›è¡Œå¤„ç†
    then(onFulfilled,onRejected) {
        // !éœ€è¦åˆ¤æ–­çŠ¶æ€
        // å…« === æ–°å¢ ===
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason};
        // å…ˆåˆ›å»ºpromise
        const promise2 = new MyPromise((resolve,reject) => {
            // å¦‚æœçŠ¶æ€æ˜¯æˆåŠŸåˆ™è°ƒç”¨onFulfilled
            if(this.status === FULFILLED) {
                // è°ƒç”¨å‡½æ•°
                // ä¿å­˜è¿”å›çš„å¤„ç†å€¼

                // äº”ã€éœ€è¦åˆ›å»ºå¾®ä»»åŠ¡ç­‰å¾…promise2åˆ›å»ºå®Œæ¯•
                queueMicrotask(() => {
                    try {
                        const x = onFulfilled(this.value)
                        // ç”¨ä¸€ä¸ªå‡½æ•°å¤„ç†å€¼ï¼Œéœ€è¦åˆ¤æ–­æ˜¯promiseè¿˜æ˜¯æ™®é€šå‡½æ•°
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(error) {
                        //! è°ƒç”¨çš„ä¼ å…¥çš„reject è€Œä¸æ˜¯this.reject
                        reject(error)
                    }
                })
            } else if (this.status === REJECTED) {
                // åŒä¸Šé¢ å¢åŠ å¾®ä»»åŠ¡
                queueMicrotask(() => {
                    try {
                        const x = onRejected(this.reason)
                        // ç”¨ä¸€ä¸ªå‡½æ•°å¤„ç†å€¼ï¼Œéœ€è¦åˆ¤æ–­æ˜¯promiseè¿˜æ˜¯æ™®é€šå‡½æ•°
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(error) {
                        //! è°ƒç”¨çš„ä¼ å…¥çš„reject è€Œä¸æ˜¯this.reject
                        reject(error)
                    }
                })
            } else if (this.status === PENDING) {
                // æ·»åŠ pendingæ—¶å€™çš„å¤„ç†
                // === æ–°å¢ ===
                // ===éœ€è¦pushè¿›å»çš„åº”è¯¥æ˜¯å¾®ä»»åŠ¡===
                this.onFulfilledCallback.push(() => {
                    queueMicrotask(() => {
                        try {
                            // è·å–æˆåŠŸå›è°ƒå‡½æ•°çš„æ‰§è¡Œç»“æœ
                            const x = onFulfilled(this.value);
                            // ä¼ å…¥ resolvePromise é›†ä¸­å¤„ç†
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (error) {
                            reject(error)
                        }
                    })
                })
                this.onRejectedCallback.push(() => {
                    queueMicrotask(() => {
                        try {
                            // è°ƒç”¨å¤±è´¥å›è°ƒï¼Œå¹¶ä¸”æŠŠåŸå› è¿”å›
                            const x = onRejected(this.reason);
                            // ä¼ å…¥ resolvePromise é›†ä¸­å¤„ç†
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (error) {
                            reject(error)
                        }
                    })
                })
            }
        })
        // ï¼ï¼è¦å°†promise2 returnå‡ºæ¥
        return promise2
    }
    // ä¹ã€å¢åŠ é™æ€æ–¹æ³•
    static resolve (parameter) {
        if(parameter instanceof MyPromise) {
            return parameter
        }
        return new MyPromise(resovle => {
            resolve(parameter)
        })
    }
    static reject (reason) {
        return new MyPromise((resolve, reject) => {
            reject(reason)
        })
    }
}
// åˆ›å»ºå‡½æ•°å¤„ç†promise
function resolvePromise (promise2, x, resolve, reject) {
    // å¦‚æœç›¸ç­‰äº†ï¼Œè¯´æ˜returnçš„æ˜¯è‡ªå·±ï¼ŒæŠ›å‡ºç±»å‹é”™è¯¯å¹¶è¿”å›
    if (promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
    }
    // // åˆ¤æ–­æ˜¯å¦promise
    // if(x instanceof MyPromise) {
    //     // æ‰§è¡Œ xï¼Œè°ƒç”¨ then æ–¹æ³•ï¼Œç›®çš„æ˜¯å°†å…¶çŠ¶æ€å˜ä¸º fulfilled æˆ–è€… rejected
    //     // x.then(value => resolve(value), reason => reject(reason))
    //     // ç®€åŒ–ä¹‹å
    //     x.then(resolve, reject)

    // ========è¿™æ³¢å±…ç„¶è¦æ”¹æˆ ===========
    if (typeof x === 'object' || typeof x === 'function') {
        // x ä¸º null ç›´æ¥è¿”å›ï¼Œèµ°åé¢çš„é€»è¾‘ä¼šæŠ¥é”™
        if (x === null) {
            return resolve(x);
        }
        let then;
        try {
            // æŠŠ x.then èµ‹å€¼ç»™ then 
            then = x.then;
        } catch (error) {
            // å¦‚æœå– x.then çš„å€¼æ—¶æŠ›å‡ºé”™è¯¯ error ï¼Œåˆ™ä»¥ error ä¸ºæ®å› æ‹’ç» promise
            return reject(error);
        }
        // å¦‚æœ then æ˜¯å‡½æ•°
        if (typeof then === 'function') {
            let called = false;
            try {
                then.call(
                x, // this æŒ‡å‘ x
                // å¦‚æœ resolvePromise ä»¥å€¼ y ä¸ºå‚æ•°è¢«è°ƒç”¨ï¼Œåˆ™è¿è¡Œ [[Resolve]](promise, y)
                y => {
                    // å¦‚æœ resolvePromise å’Œ rejectPromise å‡è¢«è°ƒç”¨ï¼Œ
                    // æˆ–è€…è¢«åŒä¸€å‚æ•°è°ƒç”¨äº†å¤šæ¬¡ï¼Œåˆ™ä¼˜å…ˆé‡‡ç”¨é¦–æ¬¡è°ƒç”¨å¹¶å¿½ç•¥å‰©ä¸‹çš„è°ƒç”¨
                    // å®ç°è¿™æ¡éœ€è¦å‰é¢åŠ ä¸€ä¸ªå˜é‡ called
                    if (called) return;
                    called = true;
                    resolvePromise(promise, y, resolve, reject);
                },
                // å¦‚æœ rejectPromise ä»¥æ®å›  r ä¸ºå‚æ•°è¢«è°ƒç”¨ï¼Œåˆ™ä»¥æ®å›  r æ‹’ç» promise
                r => {
                    if (called) return;
                    called = true;
                    reject(r);
                });
            } catch (error) {
                // å¦‚æœè°ƒç”¨ then æ–¹æ³•æŠ›å‡ºäº†å¼‚å¸¸ errorï¼š
                // å¦‚æœ resolvePromise æˆ– rejectPromise å·²ç»è¢«è°ƒç”¨ï¼Œç›´æ¥è¿”å›
                if (called) return;
                // å¦åˆ™ä»¥ error ä¸ºæ®å› æ‹’ç» promise
                reject(error);
            }
        } else {
            // å¦‚æœ then ä¸æ˜¯å‡½æ•°ï¼Œä»¥ x ä¸ºå‚æ•°æ‰§è¡Œ promise
            resolve(x);
        }
    } else {
        // æ™®é€šå€¼
        resolve(x)
    }
}
module.exports = MyPromise
```


## promiseæ–¹æ³•
> å†ç»åƒè¾›ä¸‡è‹¦ è¿˜æœ‰åƒè¾›ä¸‡è‹¦
å­¦ä¼šäº†æ‰‹å†™promiseå‡½æ•°ï¼Œè¿˜éœ€è¦å†™promise.all(),promise.race()ç­‰ç­‰,åŠ æ²¹å§å°‘å¹´  
```js

```