---
title: vue学习记录
date: 2021-04-13 22:03:08
permalink: /pages/4fffe6/
categories:
  - vue
tags:
  - 
---

 # vue总结记录

 ## VUE 特性
 1、声明式渲染
 可以使用模板语法声明式的将数据渲染进DOM系统，也就是可以在data中定义要展示的数据
 2、双向数据绑定
 实现MVVM，数据双向绑定，不再去操作DOM
 3、虚拟DOM
 更快的渲染，通过diff算法，快速比对，进行最小的DOM操作


### EventBus
```js
    //1
    const EventBus = new vue()

    //2
    Vue.prototype.$EventBus = new Vue()

    //全局
    var EventBus = new Vue()
    Object.defineProperties(Vue.prototype, {
      $bus: {
        get: function () {
          return EventBus
        }
      }
    })
```


 ## 理解记录
 1、el：element 元素每个vue实例都需要传入   
 2、vue实例的data熟悉中的数据，如果在声明的时候没有加入，后面加入是无效的，无法进行响应式展示（比如给data中只有a，后面使用的时候添加了b）
 3、使用vm和data修改数据结果相同
 4、可以使用vm.$调取vue提供的方法如vm.$watch('【监听的数据名称】,function(newVal,oldVal){【newVal和oldVal分别是新的值和旧值】}>')
 5、v-once:只使用一次的数据，后续不会再变化，不想让变化也可以使用Object.freeze()
 6、事件修饰符：.stop  .prevent .self .capture .once .passive
 7、插槽：给个入口，可以插入html模板或者组件之类
 8、vue中有filter，可以过滤，类似methods

## vue动态绑定class的几种方式
1. 对象方法

-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）

:class="{ 'active': isActive }"
判断是否绑定一个active
:class="{'active':isActive==-1}"  
或者
:class="{'active':isActive==index}"
绑定并判断多个
第一种（用逗号隔开）
:class="{ 'active': isActive, 'sort': isSort }"
第二种（放在data里面）
//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样
:class="classObject"
data() {
  return {
    classObject:{ active: true, sort:false }
  }
}
第三种（使用computed属性）
:class="classObject"
data() {
  return {
    isActive: true,
    isSort: false
  }
},
computed: {
  classObject: function () {
    return {
      active: this.isActive,
      sort:this.isSort
    }
  }
}
2. 数组方法

单纯数组
:class="[isActive,isSort]"
data() {
  return{
    isActive:'active',
    isSort:'sort'
 }
}
数组与三元运算符结合判断选择需要的class
（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）
:class="[isActive?'active':'']"
或者
:class="[isActive==1?'active':'']"
或者
:class="[isActive==index?'active':'']"
或者
:class="[isActive==index?'active':'otherActiveClass']"
数组对象结合动态判断
//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号
:class="[{ active: isActive }, 'sort']"
或者
:class="[{ active: isActive==1 }, 'sort']"
或者
:class="[{ active: isActive==index }, 'sort']"


## vue route
使用方式：
```js
//注册
//也可以import
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }
const routes = [
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
]
const router = new VueRouter({
    routes
})
const app = new Vue({
    router
}).$mount('#app')

//使用
this.$route.params//查看路由参数
//路由跳转
this.$router.push('/foo')
this.$router.go(-1)

```
## 动态路由匹配
1. 在path中使用：  以冒号让路由动态匹配路径，可以在this.$route.params中查看参数对象
2. 使用路由参数，会复用组件实例，意味着不会经过生命周期钩子，此时可以watch $route对象
3. 路由守卫中可以beforeRouteUpdate中处理
## 嵌套路由
嵌套路由中可以使用children来设置子路由

## 编程式导航
两种方式使用路由：

1. 
```js
  <router-link>
```
2. router.push(location, onComplete?, onAbort?)
如：
```js
// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
```
:::tip
注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：
:::
```js
const userId = '123'
router.push({ name: 'user', params: { userId }}) // -> /user/123
router.push({ path: `/user/${userId}` }) // -> /user/123
// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -> /user
```

## 命名路由
可以使用name标示路由
## 命名视图
多个视图可以设置名字，在components设置不同的页面
## 重定向和别名
redirect可以重定向
alias可以设置别名
## 路由传参
1. 布尔模式
2. 对象模式
3. 函数模式
项目中使用query以对象传参，页面中使用this.$route.query.【属性名】获取

## history模式
vue-router默认使用hash模式
使用时在new VueRouter的时候mode设置为history即可
history模式需要后台支持

# 进阶

## 导航守卫
1. 全局前置守卫

```js
const router = new VueRouter({ ... })

router.beforeEach((to, from, next) => {
  // ...
})
```
2. 
